import React, { useState, useEffect, useCallback } from 'react';
import { 
  View, 
  StyleSheet, 
  FlatList, 
  Text, 
  TouchableOpacity, 
  Modal, 
  Alert, 
  ActivityIndicator, 
  RefreshControl, 
  SafeAreaView,
  ScrollView 
} from 'react-native';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import { useNavigation, useFocusEffect } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { format, parseISO } from 'date-fns';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { 
  getActivities as getSupabaseActivities, 
  updateActivity, 
  deleteActivity as deleteDbActivity 
} from '../lib/supabase';
import { WorkoutEntry } from '../types/workout';
import { formatDuration } from '../utils/format';
import { 
  Activity as ActivityIcon, 
  Clock, 
  Calendar,
  MapPin, 
  Flame, 
  X 
} from 'lucide-react-native';
import ErrorBoundary from '../components/ErrorBoundary';
import WorkoutDetail from '../components/WorkoutDetail';
import { WORKOUT_HISTORY_KEY } from '../types/history';

// Define navigation types
type RootStackParamList = {
  History: undefined;
  EditWorkout: { workout: any };
  // Add other screens as needed
};

type HistoryScreenNavigationProp = NativeStackNavigationProp<RootStackParamList, 'History'>;

// Base workout item interface
interface BaseWorkoutItem {
  id: string | number;
  date: string;
  duration: number; // in seconds
  distance?: number | null; // in meters
  avgPace?: number | null; // in seconds per km/mile
  avgHeartRate?: number | null; // in bpm
  caloriesBurned?: number | null;
  notes?: string | null;
  customActivityName?: string | null;
  activityType?: string;
  source: 'run' | 'logged';
}

interface RunHistoryItem extends BaseWorkoutItem {
  source: 'run';
  id: string;
}

interface LoggedActivityItem extends BaseWorkoutItem {
  source: 'logged';
  id: number;
  type: string;
  planName?: string | null;
  created_at?: string;
  coordinates?: any[] | null;
  totalElevationGain?: number | null;
  totalElevationLoss?: number | null;
  splits?: any[] | null;
  steps?: number | null;
  calories?: number | null;
}

// Define the component
const HistoryScreen: React.FC = () => {
  // State management
  const [workouts, setWorkouts] = useState<Array<RunHistoryItem | LoggedActivityItem>>([]);
  const [selectedWorkout, setSelectedWorkout] = useState<RunHistoryItem | LoggedActivityItem | null>(null);
  const [workoutForDetailView, setWorkoutForDetailView] = useState<WorkoutEntry | null>(null);
  const [isModalVisible, setModalVisible] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const insets = useSafeAreaInsets();
  const navigation = useNavigation<HistoryScreenNavigationProp>();

  // Helper function to convert string to number safely
  const toNumber = (value: string | number | null | undefined): number => {
    if (value === null || value === undefined) return 0;
    return typeof value === 'number' ? value : parseFloat(value) || 0;
  };

  // Helper function to format distance
  const formatDistance = (meters: number | null | undefined): string => {
    if (!meters) return '0.00';
    return (meters / 1000).toFixed(2);
  };

  // Helper function to format pace
  const formatPace = (seconds: number | null | undefined): string => {
    if (!seconds) return '0:00';
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs < 10 ? '0' : ''}${secs}`;
  };

  // Handle workout press
  const handleWorkoutPress = (workout: RunHistoryItem | LoggedActivityItem) => {
    setSelectedWorkout(workout);
    
    // Convert to WorkoutEntry format for the detail view
    const entry: WorkoutEntry = {
      id: workout.id.toString(),
      date: workout.date,
      duration: toNumber(workout.duration),
      distance: toNumber(workout.distance),
      avgPace: toNumber(workout.avgPace),
      caloriesBurned: toNumber(workout.caloriesBurned || (workout as LoggedActivityItem).calories),
      avgHeartRate: toNumber(workout.avgHeartRate),
      activityType: workout.activityType || 'run',
      customActivityName: workout.customActivityName || null,
      notes: workout.notes || null,
      elevationGain: toNumber((workout as any).elevationGain || (workout as LoggedActivityItem).totalElevationGain),
      elevationLoss: toNumber((workout as any).elevationLoss || (workout as LoggedActivityItem).totalElevationLoss),
      steps: toNumber((workout as any).steps),
      splits: (workout as any).splits || [],
      coordinates: (workout as any).coordinates || [],
      planName: (workout as any).planName || null,
    };
    
    setWorkoutForDetailView(entry);
    setModalVisible(true);
  };

  // Load workouts from storage
  const loadWorkouts = useCallback(async () => {
    try {
      setIsLoading(true);
      const savedWorkouts = await AsyncStorage.getItem(WORKOUT_HISTORY_KEY);
      const localWorkouts: RunHistoryItem[] = savedWorkouts ? JSON.parse(savedWorkouts) : [];
      
      // Fetch from Supabase
      const dbActivities = await getSupabaseActivities();
      const loggedItems: LoggedActivityItem[] = dbActivities.map(activity => ({
        ...activity,
        activityType: activity.type,
        customActivityName: activity.planName || null,
        caloriesBurned: activity.caloriesBurned || activity.calories || null,
        source: 'logged',
        date: activity.created_at || new Date().toISOString(),
      }));
      
      // Combine and sort by date
      const allWorkouts = [...localWorkouts, ...loggedItems].sort((a, b) => 
        new Date(b.date).getTime() - new Date(a.date).getTime()
      );
      
      setWorkouts(allWorkouts);
    } catch (error) {
      console.error('Error loading workouts:', error);
      Alert.alert('Error', 'Failed to load workout history');
    } finally {
      setIsLoading(false);
    }
  }, []);

  // Load data on focus
  useFocusEffect(
    useCallback(() => {
      loadWorkouts();
    }, [loadWorkouts])
  );

  // Handle deleting a workout
  const handleDeleteWorkout = async (workout: RunHistoryItem | LoggedActivityItem) => {
    try {
      if (workout.source === 'logged') {
        await deleteDbActivity(workout.id as number);
      } else {
        const updatedWorkouts = workouts.filter(w => w.id !== workout.id);
        await AsyncStorage.setItem(WORKOUT_HISTORY_KEY, JSON.stringify(updatedWorkouts));
        setWorkouts(updatedWorkouts);
      }
      setModalVisible(false);
      Alert.alert('Success', 'Workout deleted successfully');
    } catch (error) {
      console.error('Error deleting workout:', error);
      Alert.alert('Error', 'Failed to delete workout');
    }
  };

  // Render loading state
  if (isLoading) {
    return (
      <View style={styles.centered}>
        <ActivityIndicator size="large" />
      </View>
    );
  }

  // Render empty state
  if (workouts.length === 0) {
    return (
      <View style={styles.centered}>
        <Text>No workouts found</Text>
      </View>
    );
  }

  return (
    <ErrorBoundary>
      <SafeAreaView style={[styles.container, { paddingTop: insets.top }]}>
        <FlatList
          data={workouts}
          keyExtractor={(item) => item.id.toString()}
          renderItem={({ item }) => (
            <TouchableOpacity 
              style={styles.workoutItem}
              onPress={() => handleWorkoutPress(item)}
              onLongPress={() => handleDeleteWorkout(item)}
            >
              <View style={styles.workoutHeader}>
                <View style={styles.dateContainer}>
                  <Calendar size={16} color="#666" style={styles.iconSmall} />
                  <Text style={styles.workoutDate}>
                    {format(new Date(item.date), 'MMM d, yyyy')}
                  </Text>
                </View>
                <Text style={styles.workoutType}>
                  {item.customActivityName || item.activityType || 'Run'}
                </Text>
              </View>
              <View style={styles.workoutDetails}>
                <View style={styles.detailItem}>
                  <Clock size={16} color="#666" />
                  <Text style={styles.detailText}>
                    {formatDuration(item.duration)}
                  </Text>
                </View>
                {item.distance && (
                  <View style={styles.detailItem}>
                    <MapPin size={16} color="#666" />
                    <Text style={styles.detailText}>
                      {formatDistance(item.distance)} km
                    </Text>
                  </View>
                )}
                {item.avgPace && (
                  <View style={styles.detailItem}>
                    <ActivityIcon size={16} color="#666" />
                    <Text style={styles.detailText}>
                      {formatPace(item.avgPace)} /km
                    </Text>
                  </View>
                )}
                {item.caloriesBurned && (
                  <View style={styles.detailItem}>
                    <Flame size={16} color="#666" />
                    <Text style={styles.detailText}>
                      {Math.round(item.caloriesBurned)} cal
                    </Text>
                  </View>
                )}
              </View>
            </TouchableOpacity>
          )}
          refreshControl={
            <RefreshControl 
              refreshing={isLoading} 
              onRefresh={loadWorkouts} 
            />
          }
        />

        {/* Workout Detail Modal */}
        <Modal
          visible={isModalVisible}
          animationType="slide"
          onRequestClose={() => setModalVisible(false)}
        >
          <View style={styles.modalContainer}>
            <View style={styles.modalHeader}>
              <TouchableOpacity 
                onPress={() => setModalVisible(false)}
                style={styles.closeButton}
              >
                <X size={24} color="#000" />
              </TouchableOpacity>
            </View>
            
            {workoutForDetailView && (
              <WorkoutDetail 
                workout={workoutForDetailView}
                onClose={() => setModalVisible(false)}
                onDelete={() => selectedWorkout && handleDeleteWorkout(selectedWorkout)}
                onEdit={() => {
                  if (!selectedWorkout) return;
                  setModalVisible(false);
                  navigation.navigate('EditWorkout', { workout: selectedWorkout });
                }}
              />
            )}
          </View>
        </Modal>
      </SafeAreaView>
    </ErrorBoundary>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
  },
  centered: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  workoutItem: {
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
    backgroundColor: '#fff',
  },
  workoutHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 8,
  },
  dateContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  workoutDate: {
    fontSize: 16,
    fontWeight: '500',
    marginLeft: 4,
  },
  workoutType: {
    fontSize: 14,
    color: '#666',
    textTransform: 'capitalize',
  },
  workoutDetails: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginTop: 8,
  },
  detailItem: {
    flexDirection: 'row',
    alignItems: 'center',
    marginRight: 16,
    marginTop: 4,
  },
  detailText: {
    marginLeft: 4,
    fontSize: 14,
    color: '#666',
  },
  iconSmall: {
    marginRight: 4,
  },
  modalContainer: {
    flex: 1,
    backgroundColor: '#fff',
  },
  modalHeader: {
    padding: 16,
    flexDirection: 'row',
    justifyContent: 'flex-end',
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  closeButton: {
    padding: 4,
  },
});

export default HistoryScreen;


const HistoryScreen: React.FC<HistoryScreenProps> = () => {
  // State management
  const [workouts, setWorkouts] = useState<Array<RunHistoryItem | LoggedActivityItem>>([]);
  const [selectedWorkout, setSelectedWorkout] = useState<RunHistoryItem | LoggedActivityItem | null>(null);
  const [workoutForDetailView, setWorkoutForDetailView] = useState<WorkoutEntry | null>(null);
  const [isModalVisible, setModalVisible] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const insets = useSafeAreaInsets();

  // Navigation setup
  const navigation = useNavigation();

  // Helper function to convert string to number safely
  const toNumber = (value: string | number | null | undefined): number => {
    if (value === null || value === undefined) return 0;
    return typeof value === 'number' ? value : parseFloat(value) || 0;
  };

  // Helper function to format distance
  const formatDistance = (meters: number | null | undefined): string => {
    if (!meters) return '0.00';
    return (meters / 1000).toFixed(2);
  };

  // Helper function to format pace
  const formatPace = (seconds: number | null | undefined): string => {
    if (!seconds) return '0:00';
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs < 10 ? '0' : ''}${secs}`;
  };

  // Handle workout press
  const handleWorkoutPress = (workout: RunHistoryItem | LoggedActivityItem) => {
    setSelectedWorkout(workout);
    
    // Convert to WorkoutEntry format for the detail view
    const entry: WorkoutEntry = {
      id: workout.id.toString(),
      date: workout.date,
      duration: toNumber(workout.duration),
      distance: toNumber(workout.distance),
      avgPace: toNumber(workout.avgPace),
      caloriesBurned: toNumber(workout.caloriesBurned || workout.calories),
      avgHeartRate: toNumber(workout.avgHeartRate),
      activityType: workout.activityType || 'run',
      customActivityName: workout.customActivityName || null,
      notes: workout.notes || null,
      elevationGain: toNumber((workout as any).elevationGain),
      elevationLoss: toNumber((workout as any).elevationLoss),
      steps: toNumber((workout as any).steps),
      splits: (workout as any).splits || [],
      coordinates: (workout as any).coordinates || [],
      planName: (workout as any).planName || null,
    };
    
    setWorkoutForDetailView(entry);
    setModalVisible(true);
  };

  // Load workouts from storage
  const loadWorkouts = useCallback(async () => {
    try {
      setIsLoading(true);
      const savedWorkouts = await AsyncStorage.getItem(WORKOUT_HISTORY_KEY);
      const localWorkouts: RunHistoryItem[] = savedWorkouts ? JSON.parse(savedWorkouts) : [];
      
      // Fetch from Supabase
      const dbActivities = await getSupabaseActivities();
      const loggedItems: LoggedActivityItem[] = dbActivities.map(activity => ({
        ...activity,
        activityType: activity.type,
        customActivityName: activity.planName || null,
        caloriesBurned: activity.caloriesBurned || activity.calories || null,
        source: 'logged' as const,
        date: activity.created_at || activity.date,
      }));
      
      // Combine and sort by date
      const allWorkouts = [...localWorkouts, ...loggedItems].sort((a, b) => 
        new Date(b.date).getTime() - new Date(a.date).getTime()
      );
      
      setWorkouts(allWorkouts);
    } catch (error) {
      console.error('Error loading workouts:', error);
      Alert.alert('Error', 'Failed to load workout history');
    } finally {
      setIsLoading(false);
    }
  }, []);

  // Load data on focus
  useFocusEffect(
    useCallback(() => {
      loadWorkouts();
    }, [loadWorkouts])
  );

  // Render loading state
  if (isLoading) {
    return (
      <View style={styles.centered}>
        <ActivityIndicator size="large" />
      </View>
    );
  }

  // Render empty state
  if (workouts.length === 0) {
    return (
      <View style={styles.centered}>
        <Text>No workouts found</Text>
      </View>
    );
  }

  return (
    <SafeAreaView style={[styles.container, { paddingTop: insets.top }]}>
      <FlatList
        data={workouts}
        keyExtractor={(item) => item.id.toString()}
        renderItem={({ item }) => (
          <TouchableOpacity 
            style={styles.workoutItem}
            onPress={() => handleWorkoutPress(item)}
          >
            <View style={styles.workoutHeader}>
              <Text style={styles.workoutDate}>
                {format(new Date(item.date), 'MMM d, yyyy')}
              </Text>
              <Text style={styles.workoutType}>
                {item.customActivityName || item.activityType || 'Run'}
              </Text>
            </View>
            <View style={styles.workoutDetails}>
              <View style={styles.detailItem}>
                <Clock size={16} color="#666" />
                <Text style={styles.detailText}>
                  {formatDuration(item.duration)}
                </Text>
              </View>
              {item.distance && (
                <View style={styles.detailItem}>
                  <MapPin size={16} color="#666" />
                  <Text style={styles.detailText}>
                    {formatDistance(item.distance)} km
                  </Text>
                </View>
              )}
              {item.avgPace && (
                <View style={styles.detailItem}>
                  <ActivityIcon size={16} color="#666" />
                  <Text style={styles.detailText}>
                    {formatPace(item.avgPace)} /km
                  </Text>
                </View>
              )}
              {item.caloriesBurned && (
                <View style={styles.detailItem}>
                  <Flame size={16} color="#666" />
                  <Text style={styles.detailText}>
                    {Math.round(item.caloriesBurned)} cal
                  </Text>
                </View>
              )}
            </View>
          </TouchableOpacity>
        )}
        refreshControl={
          <RefreshControl refreshing={isLoading} onRefresh={loadWorkouts} />
        }
      />

      {/* Workout Detail Modal */}
      <Modal
        visible={isModalVisible}
        animationType="slide"
        onRequestClose={() => setModalVisible(false)}
      >
        <View style={styles.modalContainer}>
          <View style={styles.modalHeader}>
            <TouchableOpacity 
              onPress={() => setModalVisible(false)}
              style={styles.closeButton}
            >
              <X size={24} color="#000" />
            </TouchableOpacity>
          </View>
          
          {workoutForDetailView && (
            <WorkoutDetail 
              workout={workoutForDetailView}
              onClose={() => setModalVisible(false)}
              onDelete={async () => {
                if (!selectedWorkout) return;
                
                try {
                  if ('source' in selectedWorkout && selectedWorkout.source === 'logged') {
                    await deleteDbActivity(selectedWorkout.id);
                  } else {
                    const updatedWorkouts = workouts.filter(w => w.id !== selectedWorkout.id);
                    await AsyncStorage.setItem(
                      WORKOUT_HISTORY_KEY, 
                      JSON.stringify(updatedWorkouts)
                    );
                    setWorkouts(updatedWorkouts);
                  }
                  setModalVisible(false);
                  Alert.alert('Success', 'Workout deleted successfully');
                } catch (error) {
                  console.error('Error deleting workout:', error);
                  Alert.alert('Error', 'Failed to delete workout');
                }
              }}
              onEdit={() => {
                if (!selectedWorkout) return;
                setModalVisible(false);
                navigation.navigate('EditWorkout', { workout: selectedWorkout });
              }}
            />
          )}
        </View>
      </Modal>
    </SafeAreaView>
  );
};


  id: string | number;
  date: string;
  duration: number; // in seconds
  distance?: number | null; // in meters
  avgPace?: number | null; // in seconds per km/mile
  avgHeartRate?: number | null; // in bpm
  caloriesBurned?: number | null;
  notes?: string | null;
  customActivityName?: string | null;
  activityType?: string;
  intensity?: string | null;
}

// Define a type for logged activities from the database
interface LoggedActivity extends BaseWorkoutItem {
  id: number;
  created_at?: string;
  coordinates?: any[] | null;
  planName?: string | null;
  totalElevationGain?: number | null; // in meters
  totalElevationLoss?: number | null; // in meters
  splits?: any[] | null;
  trackingMode?: string | null;
  steps?: number | null;
  user_id: string;
  endTime?: string | null;
  planId?: string | null;
  type: string; // Activity type ('Run', 'Cycling', etc.)
  // Aliases for backward compatibility
  calories?: number | null; // Alias for caloriesBurned
}

// Define a unified history item type
interface UnifiedHistoryItemBase extends BaseWorkoutItem {
  date: string; // Common property for sorting
  id: string | number; // string for runs, number for logged activities
}

interface RunHistoryItem extends UnifiedHistoryItemBase {
  source: 'run';
  id: string; // WorkoutEntry id is string
  // Add any run-specific properties here
}

interface LoggedActivityItem extends UnifiedHistoryItemBase, Omit<LoggedActivity, keyof BaseWorkoutItem> {
  source: 'logged';
  id: number; // LoggedActivity id is number
  activityType: string; // Make activityType required
}

export type UnifiedHistoryItem = RunHistoryItem | LoggedActivityItem;

// Define navigation prop types
type RootStackParamList = {
  History: undefined;
  // Add other screen params as needed
};

interface HistoryScreenProps {
  navigation: NativeStackNavigationProp<RootStackParamList, 'History'>;
}

const HistoryScreen: React.FC<HistoryScreenProps> = ({ navigation }) => {
  // State for workout data and UI
  const [workouts, setWorkouts] = React.useState<UnifiedHistoryItem[]>([]);
  const [isLoading, setIsLoading] = React.useState<boolean>(true);
  const [selectedWorkout, setSelectedWorkout] = React.useState<UnifiedHistoryItem | null>(null);
  const [workoutForDetailView, setWorkoutForDetailView] = React.useState<WorkoutEntry | null>(null);
  const [isModalVisible, setModalVisible] = React.useState<boolean>(false);
  
  const { settings } = useUserSettings();
  const insets = useSafeAreaInsets();
  const [refreshing, setRefreshing] = useState(false);
  const isMounted = useRef(true);
  const settingsRef = useRef(settings);
  
  // Update ref when settings change
  useEffect(() => {
    settingsRef.current = settings;
  }, [settings]);
  
  // Cleanup on unmount
  useEffect(() => {
    return () => {
      isMounted.current = false;
    };
  }, []);

  const loadAllHistory = useCallback(async () => {
    if (!isMounted.current) return;
    
    setIsLoading(true);
    setRefreshing(true);
    
    try {
      let combinedHistory: UnifiedHistoryItem[] = [];

      // 1. Fetch runs from AsyncStorage
      console.log('Loading workouts from AsyncStorage...');
      const storedWorkoutsJson = await AsyncStorage.getItem(WORKOUT_HISTORY_KEY);
      console.log('Stored workouts JSON:', storedWorkoutsJson);
      
      if (storedWorkoutsJson) {
        try {
          const parsedRuns: WorkoutEntry[] = JSON.parse(storedWorkoutsJson);
          console.log(`Parsed ${parsedRuns.length} runs from storage`);
          const runItems: RunHistoryItem[] = parsedRuns.map(run => ({
            ...run,
            source: 'run' as const,
            id: run.id,
            date: run.date
          }));
          combinedHistory.push(...runItems);
        } catch (parseError) {
          console.error('Error parsing stored workouts:', parseError);
        }
      } else {
        console.log('No workouts found in AsyncStorage');
      }

      // 2. Fetch logged activities from Supabase
      try {
        const dbActivities = await getActivities();
        console.log(`Fetched ${dbActivities?.length || 0} activities from Supabase.`);

        if (dbActivities && dbActivities.length > 0) {
          const loggedItems: LoggedActivityItem[] = dbActivities.map((activity: LoggedActivity) => {
            // Map all fields from the database to our unified format
            const mappedActivity = {
              ...activity,
              // Map type to activityType for backward compatibility
              activityType: activity.type,
              // Use planName as customActivityName if available
              customActivityName: activity.planName || null,
              // Map calories alias if needed
              caloriesBurned: activity.caloriesBurned || activity.calories || null,
              source: 'logged' as const,
              // Use created_at if available, otherwise fall back to date
              date: activity.created_at || activity.date,
            };
            
            console.log('Mapped activity:', {
              id: activity.id,
              type: activity.type,
              distance: activity.distance,
              duration: activity.duration,
              avgPace: activity.avgPace,
              caloriesBurned: mappedActivity.caloriesBurned,
              avgHeartRate: activity.avgHeartRate,
              intensity: activity.intensity
            });
            
            return mappedActivity;
          });
          combinedHistory.push(...loggedItems);
        }
      } catch (dbError) {
        console.error('Error fetching from Supabase:', dbError);
      }

      // 3. Sort combined history by date/created_at, most recent first
      combinedHistory.sort((a, b) => {
        // For logged activities, use created_at if available, otherwise fall back to date
        const aDate = a.source === 'logged' && (a as LoggedActivityItem).created_at 
          ? new Date((a as LoggedActivityItem).created_at!).getTime() 
          : new Date(a.date).getTime();
          
        const bDate = b.source === 'logged' && (b as LoggedActivityItem).created_at
          ? new Date((b as LoggedActivityItem).created_at!).getTime()
          : new Date(b.date).getTime();
          
        return bDate - aDate; // Sort descending (newest first)
      });
      setWorkouts(combinedHistory);
    } catch (error) {
      console.error('Failed to load history:', error);
      setWorkouts([]);
    } finally {
      if (isMounted.current) {
        setIsLoading(false);
        setRefreshing(false);
      }
    }
  }, [isMounted]);



  // Load data when component mounts
  useEffect(() => {
    loadAllHistory();
  }, [loadAllHistory]);
  
  // Refresh when screen comes into focus
  useFocusEffect(
    useCallback((): (() => void) => {
      loadAllHistory();
      return () => {}; // No cleanup needed
    }, [loadAllHistory])
  );
  
  // Pull-to-refresh handler
  const onRefresh = useCallback((): void => {
    loadAllHistory();
  }, [loadAllHistory]);

  // Define the update workout notes function with useCallback to prevent recreation
  const updateWorkoutNotes = useCallback(async (workoutId: string, notes: string) => {
    try {
      const workoutsJson = await AsyncStorage.getItem(WORKOUT_HISTORY_KEY);
      if (workoutsJson) {
        const workouts: WorkoutEntry[] = JSON.parse(workoutsJson);
        
        // Find and update the specific workout
        const updatedWorkouts = workouts.map(workout => {
          if (workout.id === workoutId) {
            return { ...workout, notes };
          }
          return workout;
        });
        
        // Save back to storage
        await AsyncStorage.setItem(WORKOUT_HISTORY_KEY, JSON.stringify(updatedWorkouts));
        
        // Update the workouts in state
        loadAllHistory();
        
        return true;
      }
    } catch (error) {
      console.error('Error updating workout notes:', error);
    }
    return false;
  }, [loadAllHistory]);
  
  // Store the function in state so it's accessible outside
  const [updateWorkoutNotesState, setUpdateWorkoutNotesState] = useState<
    ((workoutId: string, notes: string) => Promise<boolean>) | null
  >(null);

  const formatTime = (totalSeconds: number) => {
    const hours = Math.floor(totalSeconds / 3600);
    const minutes = Math.floor((totalSeconds % 3600) / 60);
    return hours > 0 ? `${hours}h ${minutes}m` : `${minutes}m`;
  };

  const getTypeStyle = (item: UnifiedHistoryItem) => {
    if (item.source === 'logged') {
      // Default style for logged activities
      return { backgroundColor: 'rgba(75, 85, 99, 0.2)', textColor: '#4b5563', borderColor: 'rgba(75, 85, 99, 0.5)' };
    }
    // Existing logic for runs (planName is on RunHistoryItem)
    const planName = item.planName;
    if (!planName) return { backgroundColor: 'rgba(107, 114, 128, 0.2)', textColor: '#6b7280', borderColor: 'rgba(107, 114, 128, 0.5)' };
    const stylesMap: { [key: string]: { backgroundColor: string; textColor: string; borderColor: string } } = {
      'Easy Run': { backgroundColor: 'rgba(34, 197, 94, 0.2)', textColor: '#22c55e', borderColor: 'rgba(34, 197, 94, 0.5)' },
      'Recovery': { backgroundColor: 'rgba(59, 130, 246, 0.2)', textColor: '#3b82f6', borderColor: 'rgba(59, 130, 246, 0.5)' },
      'Tempo': { backgroundColor: 'rgba(249, 115, 22, 0.2)', textColor: '#f97316', borderColor: 'rgba(249, 115, 22, 0.5)' },
      'Long Run': { backgroundColor: 'rgba(168, 85, 247, 0.2)', textColor: '#a855f7', borderColor: 'rgba(168, 85, 247, 0.5)' },
      'Intervals': { backgroundColor: 'rgba(239, 68, 68, 0.2)', textColor: '#ef4444', borderColor: 'rgba(239, 68, 68, 0.5)' },
    };
    return stylesMap[planName] || { backgroundColor: 'rgba(107, 114, 128, 0.2)', textColor: '#6b7280', borderColor: 'rgba(107, 114, 128, 0.5)' };
  };

  const totalStats = React.useMemo(() => {
    return {
      totalRuns: workouts.filter((w) => w.source === 'run').length,
      totalDistance: parseFloat(
        (workouts.reduce((sum, w) => {
          if (w.source === 'run') {
            const run = w as RunHistoryItem;
            return sum + (run.distance || 0);
          }
          return sum;
        }, 0) / 1000).toFixed(1) // Convert to km for display
      ),
      totalDuration: workouts.reduce((sum, w) => sum + (w.duration || 0), 0),
    };
  }, [workouts]);

  // Helper function to safely convert number | null | undefined to number | undefined
  const toNumber = (value: number | null | undefined): number | undefined => {
    return value === null ? undefined : value;
  };

  // Helper function to safely format distance for display
  const formatDistance = (meters: number | null | undefined, unit: 'mi' | 'km' = 'mi'): string => {
    const distance = toNumber(meters);
    if (distance === undefined) return '--';
    
    if (unit === 'mi') {
      const miles = distance * 0.000621371; // Convert meters to miles
      return miles.toFixed(2);
    } else {
      const kilometers = distance / 1000; // Convert meters to kilometers
      return kilometers.toFixed(2);
    }
  };

  // Helper function to safely format pace for display
  const formatPace = (secondsPerKm: number | null | undefined, unit: 'mi' | 'km' = 'mi'): string => {
    const pace = toNumber(secondsPerKm);
    if (pace === undefined) return '--:--';
    
    // Convert pace to seconds per unit
    const pacePerUnit = unit === 'mi' ? pace * 1.60934 : pace;
    
    const minutes = Math.floor(pacePerUnit / 60);
    const seconds = Math.floor(pacePerUnit % 60);
    return `${minutes}:${seconds.toString().padStart(2, '0')}`;
  };

  const handleWorkoutPress = (workout: UnifiedHistoryItem) => {
    setSelectedWorkout(workout);
    
    if (workout.source === 'run') {
      // For runs, ensure all required fields are present
      const runWorkout = workout as WorkoutEntry;
      setWorkoutForDetailView({
        ...runWorkout,
        distance: toNumber(runWorkout.distance) ?? 0,
        avgPace: toNumber(runWorkout.avgPace) ?? 0,
        coordinates: runWorkout.coordinates ?? [],
        calories: toNumber(runWorkout.calories) ?? 0,
        notes: runWorkout.notes ?? '',
        planName: runWorkout.planName ?? 'Free Run',
        avgHeartRate: toNumber(runWorkout.avgHeartRate),
        totalElevationGain: toNumber(runWorkout.totalElevationGain),
        totalElevationLoss: toNumber(runWorkout.totalElevationLoss),
        steps: toNumber(runWorkout.steps),
        splits: runWorkout.splits ?? [],
      });
    } else if (workout.source === 'logged') {
      const loggedWorkout = workout as LoggedActivityItem;
      const loggedActivityTransformed: WorkoutEntry = {
        id: String(loggedWorkout.id),
        date: loggedWorkout.date,
        duration: loggedWorkout.duration,
        distance: toNumber(loggedWorkout.distance) ?? 0,
        avgPace: toNumber(loggedWorkout.avgPace) ?? 0,
        coordinates: loggedWorkout.coordinates ?? [],
        calories: toNumber(loggedWorkout.caloriesBurned) ?? 0,
        notes: loggedWorkout.notes ?? '',
        planName: loggedWorkout.customActivityName || loggedWorkout.activityType || 'Workout',
        avgHeartRate: toNumber(loggedWorkout.avgHeartRate),
        totalElevationGain: toNumber(loggedWorkout.totalElevationGain),
        totalElevationLoss: toNumber(loggedWorkout.totalElevationLoss),
        steps: toNumber(loggedWorkout.steps),
        splits: loggedWorkout.splits ?? [],
      };
      setWorkoutForDetailView(loggedActivityTransformed);
    }
    setModalVisible(true);
  };
  };

  const handleEditActivity = (workoutId: string, currentNotes: string | undefined) => {
    if (!selectedWorkout) return;

    setModalVisible(false); // Close modal before navigating
    setWorkoutForDetailView(null);

    if (selectedWorkout.source === 'run') {
      // For runs, workoutId is the string ID from WorkoutEntry
      navigation.navigate('LogActivity', {
        screen: 'LogActivityScreen',
        params: {
          workoutId: workoutId, // This is the run's string ID
          notes: currentNotes,
          isRunNotesEdit: true, // Specific flag for editing only notes of a run
        },
      });
    } else if (selectedWorkout.source === 'logged') {
      // For logged activities, selectedWorkout.id is the numeric ID from Supabase
      // We need to fetch the full activity details to pass for editing if not already in selectedWorkout
      // Or, ensure selectedWorkout (which is LoggedActivityItem) has all necessary fields
      const activityToEdit = selectedWorkout as LoggedActivityItem;
      navigation.navigate('LogActivity', {
        screen: 'LogActivityScreen',
        params: {
          activityId: activityToEdit.id, // Numeric ID for Supabase
          activityType: activityToEdit.activityType,
          customActivityName: activityToEdit.customActivityName,
          date: activityToEdit.date,
          durationMinutes: String(activityToEdit.duration / 60),
          intensity: activityToEdit.intensity,
          notes: activityToEdit.notes,
          caloriesBurned: activityToEdit.caloriesBurned,
          isEditing: true,
        },
      });
    }
  };

  // Function to handle editing notes for tracked runs
  const handleEditRunNotes = useCallback(async (workoutId: string, currentNotes: string | undefined) => {
    // Close the modal
    setModalVisible(false);
    setWorkoutForDetailView(null); // Clear the detailed view state
    
    // Navigate to the LogActivityScreen with just the notes editing parameters
    navigation.navigate('LogActivity', {
      editMode: true,
      isRunNotesEdit: true,
      workoutId: workoutId,
      notes: currentNotes || ''
    });
  }, [navigation]);

  const handleDeleteWorkout = async (itemToDelete: UnifiedHistoryItem) => {
    Alert.alert(
      'Delete Workout',
      'Are you sure you want to delete this workout? This action cannot be undone.',
      [
        {
          text: 'Cancel',
          style: 'cancel',
        },
        {
          text: 'Delete',
          onPress: async () => {
            try {
              if (itemToDelete.source === 'run') {
                const updatedWorkouts = workouts.filter(w => w.id !== itemToDelete.id);
                const runsToSave = updatedWorkouts.filter(w => w.source === 'run') as RunHistoryItem[];
                await AsyncStorage.setItem(WORKOUT_HISTORY_KEY, JSON.stringify(runsToSave));
                setWorkouts(updatedWorkouts);
                Alert.alert('Success', 'Workout deleted.');
              } else if (itemToDelete.source === 'logged') {
                const success = await deleteDbActivity(itemToDelete.id as number);
                if (success) {
                  const updatedWorkouts = workouts.filter(w => w.id !== itemToDelete.id);
                  setWorkouts(updatedWorkouts);
                  Alert.alert('Success', 'Workout deleted.');
                } else {
                  Alert.alert('Error', 'Failed to delete workout from the database.');
                }
              }
            } catch (error) {
              console.error('Failed to delete workout:', error);
              Alert.alert('Error', 'An unexpected error occurred. Please try again.');
            }
          },
          style: 'destructive',
        },
      ],
      { cancelable: true }
    );
  };

  if (isLoading) {
    return (
      <View style={[styles.container, styles.centeredContent]}>
        <HeaderSafeArea />
        <Text style={styles.loadingText}>Loading workouts...</Text>
      </View>
    );
  }

  if (workouts.length === 0) {
    return (
      <ScrollView 
        style={[styles.container, { paddingTop: insets.top }]} 
        contentContainerStyle={styles.contentContainer}
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={onRefresh}
            colors={['#FFA500']} // Match app theme
            tintColor="#FFA500"
          />
        }
      >
        <HeaderSafeArea />
        <Text style={styles.mainTitle}>Workout History</Text>
        <Text style={styles.noWorkoutsText}>No Workouts Yet</Text>
        <Text style={styles.noWorkoutsSubText}>Complete a workout to see your history here.</Text>
      </ScrollView>
    );
  }

  return (
    <ErrorBoundary>
      <View style={styles.container}>
        <ScrollView 
          style={styles.scrollView} 
          contentContainerStyle={styles.contentContainer}
          refreshControl={
            <RefreshControl
              refreshing={refreshing}
              onRefresh={onRefresh}
              colors={['#FFA500']}
              tintColor="#FFA500"
            />
          }>
          <HeaderSafeArea />
          <View style={styles.headerTextContainer}>
            <Text style={styles.mainTitle}>Workout History</Text>
            <Text style={styles.mainSubtitle}>Review your past activities and performance.</Text>
          </View>
          {/* Summary Card */}
          <LinearGradient
            colors={['#8b5cf6', '#7c3aed']} // Violet gradient
            style={[styles.card, styles.summaryCard]}
          >
            <Text style={styles.summaryCardTitle}>Lifetime Stats</Text>
            <View style={styles.statsGrid}>
              <View style={styles.statItemWide}>
                <Text style={styles.statValue}>{totalStats.totalRuns}</Text>
                <Text style={styles.statLabel}>Total Runs</Text>
              </View>
              <View style={styles.statItemWide}>
                <Text style={styles.statValue}>{totalStats.totalDistance} km</Text>
                <Text style={styles.statLabel}>Total Distance</Text>
              </View>
              <View style={styles.statItemWide}>
                <Text style={styles.statValue}>{formatTime(totalStats.totalDuration)}</Text>
                <Text style={styles.statLabel}>Total Time</Text>
              </View>
            </View>
          </LinearGradient>

          {/* Workout List */}
          {workouts.map((item) => {
            const typeStyle = getTypeStyle(item);
            if (item.source === 'run') {
              // Render card for a Run (existing logic, ensuring item is cast to RunHistoryItem for type safety)
              const runItem = item as RunHistoryItem;
              return (
                <TouchableOpacity 
                  key={runItem.id} 
                  onPress={() => handleWorkoutPress(runItem)} 
                  onLongPress={() => handleDeleteWorkout(runItem)} 
                  style={[styles.card, styles.workoutItemCard]}
                >
                  <View style={styles.workoutItemHeader}>
                    <View style={styles.dateContainer}>
                      <Calendar size={16} color={typeStyle.textColor} style={styles.iconSmall} />
                      <Text style={[styles.dateText, { color: typeStyle.textColor }]}>
                        {new Date(runItem.date).toLocaleDateString(undefined, { month: 'short', day: 'numeric', year: 'numeric' })}
                        {' • '}
                        {new Date(runItem.date).toLocaleTimeString(undefined, { hour: 'numeric', minute: '2-digit' })}
                      </Text>
                    </View>
                    <View style={[styles.badge, { backgroundColor: typeStyle.backgroundColor, borderColor: typeStyle.borderColor }]}>
                      <Text style={[styles.badgeText, { color: typeStyle.textColor }]}>{(runItem.planName || 'Free Run').toUpperCase()}</Text>
                    </View>
                  </View>
                  <View style={styles.workoutStatsGrid}>
                    <View style={styles.workoutStatItem}>
                      <MapPin size={18} color="#9ca3af" />
                      <Text style={styles.workoutStatValue}>
                        {formatDistanceDisplay(item.distance, settings.displayUnit)}
                      </Text>
                      <Text style={styles.workoutStatLabel}>Distance</Text>
                    </View>
                    <View style={styles.workoutStatItem}>
                      <Clock size={18} color="#9ca3af" />
                      <Text style={styles.workoutStatValue}>{formatTime(item.duration)}</Text>
                      <Text style={styles.workoutStatLabel}>Duration</Text>
                    </View>
                    <View style={styles.workoutStatItem}>
                      <Zap size={16} color="#9ca3af" style={styles.iconSmall} />
                      <Text style={styles.workoutStatValue}>
                        {item.avgPace !== undefined
                          ? formatPaceDisplay(item.avgPace, settings.displayUnit)
                          : '--:--'}
                      </Text>
                      <Text style={styles.workoutStatLabel}>Avg Pace</Text>
                    </View>
                    <View style={styles.workoutStatItem}>
                      <TrendingUp size={18} color="#9ca3af" />
                      <Text style={styles.workoutStatValue}>
                        {runItem.avgHeartRate ? `${Math.round(runItem.avgHeartRate)} bpm` : 'N/A'}
                      </Text>
                      <Text style={styles.workoutStatLabel}>Avg HR</Text>
                    </View>
                  </View>
                </TouchableOpacity>
          );
        } else if (item.source === 'logged') {
          // Render card for a Logged Activity
          const loggedItem = item as LoggedActivityItem;

          // Debug and prepare display values
          console.log('RHYTHMK_DEBUG: Processing loggedItem for rendering:', JSON.stringify(loggedItem, null, 2));

          let badgeTextContent = 'WORKOUT'; // Default badge text
          if (typeof loggedItem.activityType === 'string' && loggedItem.activityType.trim() !== '') {
            badgeTextContent = loggedItem.activityType.trim().toUpperCase();
          } else if (loggedItem.activityType) {
            // Log if activityType exists but is not a usable string (e.g., empty, object, array)
            console.warn(`RHYTHMK_DEBUG: loggedItem.activityType is not a valid string: ${JSON.stringify(loggedItem.activityType)}. ID: ${loggedItem.id}`);
          }

          
          let titleTextContent = loggedItem.customActivityName || ''; // Use custom name if available
          if (!titleTextContent) { // If no custom name, derive from activityType or use default
            if (typeof loggedItem.activityType === 'string' && loggedItem.activityType.trim() !== '') {
              titleTextContent = loggedItem.activityType.trim();
            } else {
              titleTextContent = 'Workout'; // Fallback title if activityType is also unusable
            }
          }
          console.log(`RHYTHMK_DEBUG: Derived badge: \"${badgeTextContent}\", title: \"${titleTextContent}\" for ID: ${loggedItem.id}`);

          return (
            <TouchableOpacity 
              key={loggedItem.id} 
              onPress={() => handleWorkoutPress(loggedItem)} 
              onLongPress={() => handleDeleteWorkout(loggedItem)} 
              style={[styles.card, styles.workoutItemCard]}
            >
              <View style={styles.workoutItemHeader}>
                <View style={styles.dateContainer}>
                  <Calendar size={16} color={typeStyle.textColor} style={styles.iconSmall} />
                  <Text style={[styles.dateText, { color: typeStyle.textColor }]}>
                    {new Date(loggedItem.date).toLocaleDateString(undefined, { month: 'short', day: 'numeric', year: 'numeric' })}
                    {' • '}
                    {new Date(loggedItem.date).toLocaleTimeString(undefined, { hour: 'numeric', minute: '2-digit' })}
                  </Text>
                </View>
                <View style={[styles.badge, { backgroundColor: typeStyle.backgroundColor, borderColor: typeStyle.borderColor }]}>
                  <Text style={[styles.badgeText, { color: typeStyle.textColor }]}>{badgeTextContent}</Text>
                </View>
              </View>
              
              <View style={styles.workoutStatsGrid}>
                {/* For distance-based activities (Run, Bike, Walk, etc.) */}
                {['Run', 'Bike', 'Walk', 'Hike', 'Swim'].includes(loggedItem.activityType || '') ? (
                  <>
                    {/* Distance */}
                    <View style={styles.workoutStatItem}>
                      <MapPin size={16} color="#9ca3af" style={styles.iconSmall} />
                      <Text style={styles.workoutStatValue}>
                        {formatDistanceDisplay(0, settings.displayUnit)}
                      </Text>
                      <Text style={styles.workoutStatLabel}>Distance</Text>
                    </View>
                    
                    {/* Duration - Always show */}
                    <View style={styles.workoutStatItem}>
                      <Clock size={16} color="#9ca3af" style={styles.iconSmall} />
                      <Text style={styles.workoutStatValue}>
                        {formatTime(loggedItem.duration)}
                      </Text>
                      <Text style={styles.workoutStatLabel}>Duration</Text>
                    </View>
                    
                    {/* Avg Pace */}
                    <View style={styles.workoutStatItem}>
                      <Zap size={16} color="#9ca3af" style={styles.iconSmall} />
                      <Text style={styles.workoutStatValue}>
                        --:--
                      </Text>
                      <Text style={styles.workoutStatLabel}>Avg Pace</Text>
                    </View>
                    
                    {/* Avg HR - Show if available */}
                    <View style={styles.workoutStatItem}>
                      <TrendingUp size={16} color="#9ca3af" style={styles.iconSmall} />
                      <Text style={styles.workoutStatValue}>
                        {loggedItem.avgHeartRate ? `${Math.round(loggedItem.avgHeartRate)} bpm` : '--'}
                      </Text>
                      <Text style={styles.workoutStatLabel}>Avg HR</Text>
                    </View>
                  </>
                ) : (
                  /* For non-distance activities (Weight Training, Yoga, etc.) */
                  <>
                    {/* Activity Type */}
                    <View style={styles.workoutStatItem}>
                      <Activity size={16} color="#9ca3af" style={styles.iconSmall} />
                      <Text style={styles.workoutStatValue}>
                        {loggedItem.activityType || 'Workout'}
                      </Text>
                      <Text style={styles.workoutStatLabel}>Activity</Text>
                    </View>
                    
                    {/* Duration - Always show */}
                    <View style={styles.workoutStatItem}>
                      <Clock size={16} color="#9ca3af" style={styles.iconSmall} />
                      <Text style={styles.workoutStatValue}>
                        {formatTime(loggedItem.duration)}
                      </Text>
                      <Text style={styles.workoutStatLabel}>Duration</Text>
                    </View>
                    
                    {/* Intensity - Show if available */}
                    <View style={styles.workoutStatItem}>
                      <Zap size={16} color="#9ca3af" style={styles.iconSmall} />
                      <Text style={styles.workoutStatValue}>
                        {loggedItem.intensity || '--'}
                      </Text>
                      <Text style={styles.workoutStatLabel}>Intensity</Text>
                    </View>
                    
                    {/* Calories - Show if available */}
                    <View style={styles.workoutStatItem}>
                      <Flame size={16} color="#9ca3af" style={styles.iconSmall} />
                      <Text style={styles.workoutStatValue}>
                        {loggedItem.caloriesBurned || '--'}
                      </Text>
                      <Text style={styles.workoutStatLabel}>Calories</Text>
                    </View>
                  </>
                )}
              </View>
              {loggedItem.notes && <Text style={[styles.itemNotes, {color: typeStyle.textColor}]}>Notes: {loggedItem.notes}</Text>}
            </TouchableOpacity>
          );
        }
        return null; // Should not happen
          })}

          {/* Workout Detail Modal */}
          {modalVisible && workoutForDetailView && (
            <Modal
              animationType="slide"
              transparent={true}
              visible={modalVisible}
              onRequestClose={() => {
                setModalVisible(!modalVisible);
              }}>
              <View style={styles.modalOverlay}>
                <View style={styles.modalContent}>
                  <View style={styles.modalHeader}>
                    <Text style={styles.modalTitle}>Workout Details</Text>
                    <TouchableOpacity onPress={() => setModalVisible(false)}>
                      <X size={24} color="white" />
                    </TouchableOpacity>
                  </View>
                  <ErrorBoundary>
                    <WorkoutDetail 
                      workout={workoutForDetailView as WorkoutEntry} 
                      onEditNotes={handleEditActivity} 
                    />
                  </ErrorBoundary>
                </View>
              </View>
            </Modal>
          )}
        </ScrollView>
      </View>
    </ErrorBoundary>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#111827', // slate-900 (darker than #121212)
  },
  scrollView: {
    flex: 1,
  },
  contentContainer: {
    padding: 16,
    paddingBottom: 32, // Ensure space for last item
  },
  headerTextContainer: {
    alignItems: 'center',
    marginBottom: 24,
  },
  mainTitle: {
    fontSize: 24,
    fontWeight: 'bold',
    color: 'white',
    marginBottom: 4,
  },
  mainSubtitle: {
    fontSize: 16,
    color: '#94a3b8', // slate-400
  },
  card: {
    backgroundColor: '#1e293b', // slate-800
    borderRadius: 8, // Consistent border radius
    padding: 16,
    marginBottom: 16,
    borderColor: '#334155', // slate-700
    borderWidth: 1,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.2,
    shadowRadius: 2,
    elevation: 3,
  },
  summaryCard: {
    // backgroundColor was '#8b5cf6', now handled by LinearGradient
    marginBottom: 20,
  },
  summaryCardTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: 'white',
    marginBottom: 12,
    textAlign: 'center',
  },
  statsGrid: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    width: '100%',
  },
  statItemWide: {
    alignItems: 'center',
    flex: 1, // Allow items to take equal width
  },
  statValue: {
    fontSize: 20,
    fontWeight: 'bold',
    color: 'white',
  },
  statLabel: {
    fontSize: 12,
    color: 'rgba(255, 255, 255, 0.8)',
    marginTop: 2,
  },
  workoutItemCard: {
    marginBottom: 12,
  },
  workoutStatItem: {
    alignItems: 'center',
    flex: 1,
    paddingHorizontal: 4, // Add some spacing between items
  },
  workoutStatValue: {
    fontSize: 15,
    fontWeight: '600',
    color: 'white',
    marginTop: 2,
  },
  workoutStatLabel: {
    fontSize: 11,
    color: '#9ca3af',
    marginTop: 2,
    textAlign: 'center',
  },
  workoutStatsGrid: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: 8,
  },
  dateText: {
    fontSize: 14,
    fontWeight: '500',
  },
  iconSmall: {
    marginRight: 6,
  },
  dateContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  workoutItemHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 12,
  },
  badge: {
    paddingHorizontal: 10,
    paddingVertical: 4,
    borderRadius: 8,
    borderWidth: 1,
  },
  badgeText: {
    fontSize: 11,
    fontWeight: '600',
  },
  modalOverlay: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.75)', // Darker overlay
  },
  modalContent: {
    width: '90%',
    maxHeight: '85%', // Slightly increased maxHeight
    backgroundColor: '#1e293b', // slate-800 (consistent with cards)
    borderRadius: 8, // Consistent border radius
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.25,
    shadowRadius: 4,
    elevation: 5,
    overflow: 'hidden', // Ensures children (ScrollView) respect border radius
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    borderBottomWidth: 1,
    borderBottomColor: '#334155', // slate-700
    paddingHorizontal: 16, // Consistent horizontal padding
    paddingVertical: 16,
    backgroundColor: '#273246', // Slightly different shade for header, slate-800 variant
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: 'white',
  },
  loggedActivityTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    marginTop: 10,
    marginBottom: 5,
    color: 'white',
  },
  loggedActivityDetailsContainer: {
    marginTop: 8,
  },
  loggedActivityDetailItem: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 4,
  },
  loggedActivityDetailText: {
    fontSize: 14,
    marginLeft: 6,
    color: '#e2e8f0',
  },
  itemNotes: {
    fontSize: 13,
    fontStyle: 'italic',
    color: '#9ca3af',
    marginTop: 8,
  },
  centeredContent: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    fontSize: 18,
    color: 'white',
    textAlign: 'center',
    marginTop: 50,
  },
  noWorkoutsText: {
    fontSize: 22,
    fontWeight: 'bold',
    color: 'white',
    marginBottom: 8,
    textAlign: 'center',
  },
  noWorkoutsSubText: {
    fontSize: 16,
    color: '#9ca3af', // slate-400
    textAlign: 'center',
    paddingHorizontal: 20,
    marginBottom: 12,
  }
  // WorkoutDetail will be wrapped in a ScrollView inside the modal
  // so styles for detailLabel, detailValue are in WorkoutDetail.tsx
});

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
  },
  centered: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  workoutItem: {
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  workoutHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 8,
  },
  workoutDate: {
    fontSize: 16,
    fontWeight: '500',
  },
  workoutType: {
    fontSize: 14,
    color: '#666',
  },
  workoutDetails: {
    flexDirection: 'row',
    flexWrap: 'wrap',
  },
  detailItem: {
    flexDirection: 'row',
    alignItems: 'center',
    marginRight: 16,
    marginTop: 4,
  },
  detailText: {
    marginLeft: 4,
    fontSize: 14,
    color: '#666',
  },
  modalContainer: {
    flex: 1,
    backgroundColor: '#fff',
  },
  modalHeader: {
    padding: 16,
    flexDirection: 'row',
    justifyContent: 'flex-end',
  },
  closeButton: {
    padding: 4,
  },
});

export default HistoryScreen;
